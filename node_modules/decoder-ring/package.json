{
  "name": "decoder-ring",
  "version": "0.4.0",
  "description": "Decode binary buffers using a JSON specification",
  "main": "lib/DecoderRing.js",
  "scripts": {
    "pretest": "rm -rf lib; coffee -o lib -c src/*.coffee",
    "prepublish": "rm -rf lib; coffee -o lib -c src/*.coffee",
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/asbaker/node-decoder-ring"
  },
  "keywords": [
    "buffer",
    "binary",
    "decode"
  ],
  "author": {
    "name": "Tony Baker",
    "email": "anthony.s.baker@gmail.com"
  },
  "contributors": [
    {
      "name": "Jacob Jewell",
      "email": "jakesjews@immersiveapplications.com"
    }
  ],
  "license": "MIT",
  "dependencies": {},
  "devDependencies": {
    "mocha": "1.8.1",
    "chai": "1.5.0",
    "sinon": "1.6.0",
    "coffee-script": "1.6.2"
  },
  "engines": {
    "node": ">= 0.6"
  },
  "bugs": {
    "url": "http://github.com/asbaker/node-decoder-ring/issues"
  },
  "homepage": "http://github.com/asbaker/node-decoder-ring",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/asbaker/node-decoder-ring/raw/master/LICENSE"
    }
  ],
  "readme": "node-decoder-ring\n=================\n\n[![Build Status](https://travis-ci.org/asbaker/node-decoder-ring.png)](https://travis-ci.org/asbaker/node-decoder-ring])\n\n*IMPORTANT: This module only works with node v0.6.0 and later.*\n\nDecoder Ring allows you to use a Javascript object as a specification to decode [Node.js Buffers](http://nodejs.org/api/buffer.html) into a Javascript object.\n\n## Installation\n\n\tnpm install decoder-ring\n\n##  Usage\n\n\n### Javascript Object Specification\n\nThe Javascript object specification is used to specify endianness and a description of the fields present in the buffer.\n```javascript\n{\n    bigEndian: true,\n    fields: [\n        {name: \"field1\", start: 0,  type: 'int8'  },\n        {name: \"field2\", start: 1,  type: 'uint8' },\n        {name: \"field3\", start: 2,  type: 'int16' },\n        {name: \"field4\", start: 4,  type: 'uint16'},\n        {name: \"field5\", start: 6,  type: 'float' },\n        {name: \"field6\", start: 10, type: 'double'},\n        {name: \"field7\", start: 18, type: 'ascii', length: 10 },\n        {name: \"field8\", start: 28, type: 'utf8',  length: 9  },\n        {name: \"field9\", start: 37, type: 'bit', position: 7},\n        {name: \"field10\", start: 37, type: 'bit', position: 6},\n        {name: \"field11\", start: 37, type: 'bit', position: 0},\n        {name: \"field12\", start: 38, type: 'uint32'},\n        {name: \"field13\", start: 42, type: 'int32'}\n        {name: \"field14\", start: 46, type: 'int8', default: 42 }\n    ]\n}\n\n\n```\n\nAll fields must have a name, a starting byte, and a type. The name is used for assigning the property in the resulting javascript object. Additionally, fields can have a default value which is used when encoding an object's properties that have null or undefined values.\n\n#### Types\n* **int8** - Signed 8-bit integer\n* **uint8** - Unsigned 8-bit integer\n* **int16** - Signed 16-bit integer\n* **uint16** - Unsigned 16-bit integer\n* **int32** - Signed 32-bit integer\n* **uint32** - Unsigned 32-bit integer\n* **float** - 4-bit floating point number\n* **double** - 8-bit double precision floating point number\n* **ascii** - 8-bit per character ASCII encoded text\n\n\tThis field type must also have a length property which is a count of the number of characters.\n* **utf8** - 8-bit per character UTF8 encoded text\n\n\tThis field type must also have a length property which is a count of the number of characters.\n* **bit** - true/false values\n\n\tBit fields are pieces of a 1-byte unsigned integer. Given a big endian, unsigned integer of 129, it will appear as the following when broken down into bits:\n\n\n  | 128(2^7) | 64(2^6) | 32(2^5) | 16(2^4) | 8(2^3) | 4(2^2) | 2(2^1) | 1(2^0) |\n  | :--:\t | :--:\t| :--:\t| :--:\t| :--:   | :--:   | :--:   | :--:   |\n  | 1\t\t| 0\t   | 0\t   | 0\t   | 0\t  | 0\t  | 0\t  | 1\t  |\n\n\tBit fields must have a position property which is used to check if a specific bit is on or off in the 1-byte unsigned integer.\n\tThe position of the bit of interest, is defined as which power of two the bit falls in the integer. For the bit in the 128th's place, the position would be 7, for the bit in the 1's place the position would be 0.\n\n\n### Example\n\n```javascript\nvar DecoderRing = require(\"decoder-ring\")\nvar decoderRing = new DecoderRing();\n\nvar bufferBE = new Buffer(47)\nbufferBE.fill(0)\nbufferBE.writeInt8(-127, 0)\nbufferBE.writeUInt8(254, 1)\nbufferBE.writeInt16BE(5327, 2)\nbufferBE.writeUInt16BE(5328, 4)\nbufferBE.writeFloatBE(-15.33, 6)\nbufferBE.writeDoubleBE(-1534.98, 10)\nbufferBE.write(\"ascii\", 18, 10,'ascii')\nbufferBE.write(\"utf8 text\", 28, 9, 'utf8')\nbufferBE.writeUInt8(129, 37)\nbufferBE.writeUInt32BE(79001, 38)\nbufferBE.writeInt32BE(-79001, 42)\nbufferBE.writeInt8(1, 46)\n\nvar spec = {\n  bigEndian: true,\n  fields: [\n    { name: \"field1\", start: 0,   type: 'int8'  },\n    { name: \"field2\", start: 1,   type: 'uint8' },\n    { name: \"field3\", start: 2,   type: 'int16' },\n    { name: \"field4\", start: 4,   type: 'uint16'},\n    { name: \"field5\", start: 6,   type: 'float' },\n    { name: \"field6\", start: 10,  type: 'double'},\n    { name: \"field7\", start: 18,  type: 'ascii',length: 10 },\n    { name: \"field8\", start: 28,  type: 'utf8', length: 9  },\n    { name: \"field9\", start: 37,  type: 'bit', position: 7 },\n    { name: \"field10\", start: 37, type: 'bit', position: 6 },\n    { name: \"field11\", start: 37, type: 'bit', position: 0 },\n    { name: \"field12\", start: 38, type: 'uint32' },\n    { name: \"field13\", start: 42, type: 'int32' },\n    { name: \"field14\", start: 46, type: 'int8', default: 42 }\n  ]\n}\n\n// Decode the buffer into a javascript object\nvar result = decoderRing.decode(bufferBE, spec)\nconsole.log(result)\n\n// Assign field14 to undefined to test default value on encoding\nresult.field14 = undefined\n\n// Encode the object to a buffer\nvar buffer = decoderRing.encode(result, spec)\nconsole.log(buffer)\n\n// Decode buffer to object and check field14 for default value\nvar resultWithDefaultValue = decoderRing.decode(buffer, spec)\nconsole.log(\"Field14 default value: \" + resultWithDefaultValue.field14)\n```\n\nResult of the above example\n\n```javascript\n{ field1: -127,\n  field2: 254,\n  field3: 5327,\n  field4: 5328,\n  field5: -15.329999923706055,\n  field6: -1534.98,\n  field7: 'ascii\\u0000\\u0000\\u0000\\u0000\\u0000',\n  field8: 'utf8 text',\n  field9: true,\n  field10: false,\n  field11: true,\n  field12: 79001,\n  field13: -79001,\n  field14: 1 }\n\n<Buffer 81 fe 14 cf 14 d0 c1 75 47 ae c0 97 fb eb 85 1e b8 52 61 73 63 69 69 20 20 20 20 20 75 74 66 38 20 74 65 78 74 81 00 01 34 99 ff fe cb 67 2a>\n\nField14 42\n```\n\n## Development\n\n### Running tests\n\tnpm test\n\n### Testing the package locally\n\tnpm pack\n\tnpm install decoder-ring-0.4.0.tgz\n\tnode example.js\n\n\n",
  "readmeFilename": "README.md",
  "_id": "decoder-ring@0.4.0",
  "_from": "decoder-ring@"
}
